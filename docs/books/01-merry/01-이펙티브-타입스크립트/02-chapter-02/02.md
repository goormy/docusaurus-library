---
sidebar_label: 아이템 7 타입이 값들의 집합이라고 생각하기
title: 타입이 값들의 집합이라고 생각하기
---

## 타입과 값의 관계

런타임에 모든 변수는 자바스크립트 세상의 값으로부터 정해지는 각자의 고유한 값을 가집니다. 그러나 코드가 실행되지 전, 즉 타입스크립트가 오류를 체크하는 순간에는 '타입'을 가지고 있습니다. '할당 가능한 값들의 집합'이 타입이라고 생각하면 됩니다. 이 집합은 타입의 '범위'라고 부르기도 합니다. 예를 들어, 모든 숫자값의 집합을 number 타입이라고 생각할 수 있습니다.

가장 작은 집합은 아무 값도 포함하지 않는 공집합이며, 타입스크립트에서 never 타입입니다. never 타입으로 선언된 변수의 범위는 공집합이기 때문에 아무런 값도 할당할 수 없습니다.

```ts
const x: never = 12;
// '12' 형식은 'never' 형식에 할당할 수 없습니다.
```

그 다음으로 작은 집합은 한 가지 값만 포함하는 타입입니다. 이들은 타입스크립트에서 유닛(unit) 타입이라고도 불리는 리터럴(literal) 타입입니다.

```ts
type A = 'A';
type B = 'B';
type Twelve = 12;
```

두 개 혹은 세 개로 묶으려면 유니온(union) 타입을 사용합니다.

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
Footer;
```

세 개 이상의 타입을 묶을 때도 동일하게 |로 이어주면 됩니다. 유니온 타입은 값 집합들의 합집합을 일컫습니다.

다양한 타입스크립트 오류에서 '할당 가능한'이라는 문구를 볼 수 있습니다. 이 문구는 집합의 관점에서, '~의 원소(값과 타입의 관계)' 또는 '~의 부분 집합(두 타입의 관계)'을 의미합니다.

```ts
type AB = 'A' | 'B';
type AB12 = 'A' | 'B' | 12;
const a: AB = 'A'; // 정상, 'A' 는 집합 {'A', 'B'}의 원소입니다.
const c: AB = 'C';
// ~ '"C"' 형식은 'AB' 형식에 할당할 수 없습니다.
```

"C"는 유닛 타입입니다. 범위는 단일 값 "C"로 구성되며 AB("A"와 "B"로 이루어진) 부분 집합이 아니므로 오류입니다. 집합의 관점에서, 타입 체커의 주요 역할은 하나의 집합이 다른 집합의 부분 집합인지 검사하는 것이라고 볼 수 있습니다.

다음처럼 원소를 서술하는 방법도 있습니다.

```ts
interface Identified {
	id: string;
}
```

앞의 인터페이스가 타입 범위 내의 값들에 대한 설명이라고 생각해 보겠습니다. 어떤 객체가 string으로 할당 가능한 id 속성을 가지고 있다면 그 객체는 Identified입니다. 이 설명이 아이템에서 말하고자 하는 '전부'입니다. 아이템 4에서 설명했듯이, 구조적 타이핑 규칙들은 어떠한 값이 다른 속성도 가질 수 있음을 의미합니다. 이러한 사실은 특정 상황에서만 추가 속성을 허용하지 않는 잉여 속성 체크만 생각하다 보면 간과하기 쉽습니다.

연산과 관련된 이해를 돕기 위해 값의 집합을 타입이라고 생각해 봅시다.

```ts
interface Identified {
	id: string;
}
interface Person {
	name: string;
}
interface Lifespan {
	birth: Date;
	death?: Date;
}
type PersonSpan = Person & Lifespan;
```

& 연산자는 두 타입의 인터섹션(intersection, 교집합)을 계산합니다. 언뜻 보기에 Person과 Lifespan 인터페이스는 공통으로 가지는 속성이 없기 때문에, PersonSpan 타입을 공집합(never 타입)으로 예상하기 쉽습니다. 그러나 타입 연산자는 인터페이스의 속성이 아닌, 값의 집합에 적용됩니다. 그리고 추가적인 속성을 가지는 값도 여전히 그 타입에 속합니다. 그래서 Person과 Lifespan을 둘 다 가지는 값은 인터섹션 타입에 속하게 됩니다.

```ts
const ps: PersonSpan = {
	name: 'Alan Turing',
	birth: new Date('1912/06/23'),
	death: new Date('1954/06/07'),
}; // 정상
```

인터섹션 타입의 값은 각 타입 내의 속성을 모두 포함하는 것이 일반적인 규칙입니다. 규칙이 속성에 대한 인터섹션에 관해서는 맞지만, 두 인터페이스의 유니온에서는 그렇지 않습니다.

```ts
type K = keyof (Person | Lifespan); // 타입이 never
```

앞의 유니온 타입에 속하는 값은 어떠한 키도 없기 때문에, 유니온에 대한 keyof는 공집합(never)이어야만 합니다. 조금 더 명확히 써 보자면 다음과 같습니다.

```ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

이 등식은 타입스크립트의 타입 시스템을 이해하는 데 큰 도움이 될 것입니다. 조금 더 일반적으로 PersonSpan 타입을 선언하는 방법은 extends 키워드를 쓰는 것입니다.

```ts
interface Person {
	name: string;
}
interface PersonSpan extends Person {
	birth: Date;
	death?: Date;
}
```

타입이 집합이라는 관점에서 extends의 의미는 '~에 할당 가능한'과 비슷하게, '~의 부분 집합'이라는 의미로 받아들일 수 있습니다. PersonSpan 타입의 모든 값은 문자열 name 속성을 가져야 합니다. 그리고 birth 속성을 가져야 제대로 된 부분 집합이 됩니다.

## 요약

:::info

-   타입을 값의 집합으로 생각하면 이해하기 편합니다(타입의 '범위'). 이 집합은 유한(boolean 또는 리터럴 타입)하거나 무한(number 또는 string)합니다.
-   타입스크립트 타입은 엄격한 상속 관계가 아니라 겹쳐지는(벤다이어그램)으로 표현됩니다. 두 타입은 서로 서브타입이 아니면서도 겹쳐질 수 있습니다.
-   한 객체의 추가적인 속성이 타입 선언에 언급되지 않더라도 그 타입에 속할 수 있습니다.
-   타입 연산은 집합의 범위에 적용됩니다. A와 B의 인터섹션은 A의 범위와 B의 범위의 인터섹션입니다. 객체 타입에서는 A & B인 값이 A와 B의 속성을 모두 가짐을 의미합니다.
-   'A는 B를 상속', 'A는 B에 할당 가능', 'A는 B의 서브타입'은 'A는 B의 부분 집합과 같은 의미입니다.

:::
